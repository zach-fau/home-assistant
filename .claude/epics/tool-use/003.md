---
name: Error Handling & Configuration
status: open
created: 2025-10-29T21:30:40Z
updated: 2025-10-29T21:30:40Z
github: null
depends_on: [001, 002]
parallel: false
conflicts_with: []
---

# Task: Error Handling & Configuration

## Description

Implement robust error handling for function calls, add retry logic for transient failures, create comprehensive configuration management, and document the setup process. Ensure graceful degradation when external services are unavailable and provide clear voice feedback for all error scenarios.

**Key Outcome:** Alex handles errors gracefully, provides helpful voice feedback, and the system is easy to configure and troubleshoot.

## Acceptance Criteria

- [ ] Retry logic implemented for network errors (2 retries with exponential backoff)
- [ ] Timeout handling for slow API calls (configurable per service)
- [ ] Authentication errors handled with clear voice messages
- [ ] Service unavailable errors don't crash the bot
- [ ] Configuration validation on startup (check required env vars)
- [ ] Logging system implemented (DEBUG level during development)
- [ ] README.md updated with complete setup instructions
- [ ] Error messages are user-friendly and actionable
- [ ] Function failures return meaningful error objects
- [ ] Voice feedback for all error scenarios

## Technical Details

### Files to Create
1. `pipecat-quickstart/functions/utils.py` - Shared utilities
2. `pipecat-quickstart/config/README.md` - Configuration guide
3. `pipecat-quickstart/SETUP_GUIDE.md` - Complete setup documentation

### Files to Modify
1. `pipecat-quickstart/functions/home_assistant.py` - Add error handling
2. `pipecat-quickstart/functions/__init__.py` - Add config validation
3. `pipecat-quickstart/bot.py` - Add startup validation
4. `pipecat-quickstart/README.md` - Update with function calling docs

### Implementation Approach

**1. Shared Utilities (`functions/utils.py`):**
```python
import httpx
import logging
import asyncio
from typing import Optional, Dict, Any

logger = logging.getLogger(__name__)

class FunctionCallError(Exception):
    """Base exception for function call errors"""
    def __init__(self, message: str, user_message: str = None):
        self.message = message
        self.user_message = user_message or "Sorry, something went wrong."
        super().__init__(self.message)

class ServiceUnavailableError(FunctionCallError):
    """Service is unreachable"""
    pass

class AuthenticationError(FunctionCallError):
    """Authentication failed"""
    pass

class TimeoutError(FunctionCallError):
    """Request timed out"""
    pass

async def retry_async(func, max_retries=2, backoff_factor=1.5):
    """
    Retry async function with exponential backoff

    Args:
        func: Async function to retry
        max_retries: Maximum number of retries
        backoff_factor: Multiplier for delay between retries
    """
    for attempt in range(max_retries + 1):
        try:
            return await func()
        except httpx.NetworkError as e:
            if attempt == max_retries:
                raise ServiceUnavailableError(
                    str(e),
                    "Sorry, I couldn't reach the service. Please check your network connection."
                )
            delay = backoff_factor ** attempt
            logger.warning(f"Network error on attempt {attempt + 1}, retrying in {delay}s: {e}")
            await asyncio.sleep(delay)
        except httpx.HTTPStatusError as e:
            if e.response.status_code == 401 or e.response.status_code == 403:
                raise AuthenticationError(
                    str(e),
                    "Sorry, authentication failed. Please check your API credentials."
                )
            raise
        except httpx.TimeoutException as e:
            if attempt == max_retries:
                raise TimeoutError(
                    str(e),
                    "Sorry, that took too long. The service might be slow right now."
                )
            logger.warning(f"Timeout on attempt {attempt + 1}, retrying...")
            await asyncio.sleep(backoff_factor ** attempt)

def validate_config() -> Dict[str, Any]:
    """
    Validate configuration on startup
    Returns dict of validation results
    """
    import os

    results = {
        "valid": True,
        "errors": [],
        "warnings": []
    }

    # Check Home Assistant config
    if not os.getenv("HOME_ASSISTANT_URL"):
        results["errors"].append("HOME_ASSISTANT_URL not set in .env")
        results["valid"] = False

    if not os.getenv("HOME_ASSISTANT_TOKEN"):
        results["errors"].append("HOME_ASSISTANT_TOKEN not set in .env")
        results["valid"] = False

    # Check if config files exist
    from pathlib import Path
    config_dir = Path(__file__).parent.parent / "config"

    if not (config_dir / "ha_entities.json").exists():
        results["warnings"].append("config/ha_entities.json not found - Home Assistant functions may not work")

    return results

def setup_logging(level=logging.DEBUG):
    """Configure logging for function calls"""
    logging.basicConfig(
        level=level,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
```

**2. Enhanced Error Handling in Home Assistant (`functions/home_assistant.py`):**
```python
from .utils import retry_async, FunctionCallError, ServiceUnavailableError, logger

async def control_light_handler(entity_id: str, action: str, brightness: int = None, color: str = None):
    """Control a light device with error handling"""
    resolved_id = resolve_entity(entity_id, "lights")

    async def _make_request():
        service = f"light/{action}"
        data = {"entity_id": resolved_id}

        if brightness is not None:
            data["brightness"] = brightness
        if color:
            data["rgb_color"] = tuple(int(color.lstrip('#')[i:i+2], 16) for i in (0, 2, 4))

        async with httpx.AsyncClient(timeout=5.0) as client:
            response = await client.post(
                f"{HA_URL}/api/services/{service}",
                headers=HA_HEADERS,
                json=data
            )
            response.raise_for_status()
            return response

    try:
        await retry_async(_make_request)
        logger.info(f"Successfully controlled light: {resolved_id} -> {action}")
        return {
            "success": True,
            "entity": resolved_id,
            "action": action,
            "message": f"{entity_id} is now {action.replace('turn_', '')}"
        }
    except FunctionCallError as e:
        logger.error(f"Failed to control light {resolved_id}: {e.message}")
        return {
            "success": False,
            "error": e.message,
            "user_message": e.user_message,
            "entity": resolved_id
        }
    except Exception as e:
        logger.exception(f"Unexpected error controlling light {resolved_id}")
        return {
            "success": False,
            "error": str(e),
            "user_message": f"Sorry, I couldn't control {entity_id} right now."
        }
```

**3. Startup Validation (`bot.py`):**
```python
from functions.utils import validate_config, setup_logging

# At startup, before initializing services
setup_logging()
logger = logging.getLogger(__name__)

logger.info("Validating configuration...")
config_results = validate_config()

if not config_results["valid"]:
    logger.error("Configuration errors found:")
    for error in config_results["errors"]:
        logger.error(f"  - {error}")
    raise RuntimeError("Invalid configuration, see errors above")

if config_results["warnings"]:
    logger.warning("Configuration warnings:")
    for warning in config_results["warnings"]:
        logger.warning(f"  - {warning}")

logger.info("Configuration valid, starting bot...")
```

**4. Enhanced Event Handlers (`functions/__init__.py`):**
```python
@llm.event_handler("on_function_calls_failed")
async def on_function_error(service, error):
    """Handle function call failures with helpful voice feedback"""
    error_message = getattr(error, 'user_message', "Sorry, something went wrong.")
    logger.error(f"Function call failed: {error}")

    # Generate voice feedback
    from pipecat.frames import TTSSpeakFrame
    await tts.queue_frame(TTSSpeakFrame(error_message))
```

**5. Configuration Guide (`config/README.md`):**
```markdown
# Configuration Guide

## Home Assistant Setup

1. Generate a long-lived access token:
   - Go to your Home Assistant profile
   - Scroll to "Long-Lived Access Tokens"
   - Click "Create Token"
   - Copy the token immediately (can't view later)

2. Update `.env`:
   ```bash
   HOME_ASSISTANT_URL=http://homeassistant.local:8123
   HOME_ASSISTANT_TOKEN=your_token_here
   ```

3. Map your devices in `config/ha_entities.json`:
   ```json
   {
     "lights": {
       "living_room": "light.living_room_main",
       "bedroom": "light.bedroom_ceiling"
     },
     "switches": {
       "porch": "switch.front_porch"
     }
   }
   ```

## Finding Entity IDs

1. Go to Home Assistant → Developer Tools → States
2. Search for your device
3. Copy the entity ID (e.g., `light.living_room`)
4. Add friendly name mapping to config
```

### Testing Strategy

**Error Scenarios to Test:**

1. **Network Errors:**
   - Disconnect from network → Voice says "couldn't reach the service"
   - Verify 2 retries happen with backoff

2. **Authentication Errors:**
   - Use invalid token → Voice says "authentication failed"
   - No retries (fail fast)

3. **Timeout:**
   - Slow network response → Retries with timeout
   - Voice feedback if all retries fail

4. **Service Down:**
   - Stop Home Assistant → Graceful error message
   - Bot continues running (doesn't crash)

5. **Invalid Config:**
   - Missing HOME_ASSISTANT_URL → Startup error with clear message
   - Missing config file → Warning but bot starts

6. **Invalid Entity:**
   - Request nonexistent device → Clear error message

## Dependencies

### External Dependencies
- Python `logging` module (built-in)
- `httpx` with retry capabilities

### Blocked By
- Task 001 (Function Calling Framework) - must be complete
- Task 002 (Home Assistant Integration) - needs functions to add error handling to

### Blocks
- None (improves existing functionality)

## Effort Estimate

- **Size:** M (Medium)
- **Hours:** 6-10 hours
- **Parallel:** false (depends on Tasks 001 and 002)

**Breakdown:**
- Utilities and error classes: 2 hours
- Retry logic implementation: 2 hours
- Configuration validation: 1 hour
- Update existing code with error handling: 2 hours
- Documentation: 2 hours
- Testing error scenarios: 2 hours

## Definition of Done

- [ ] All acceptance criteria met
- [ ] All error scenarios tested manually
- [ ] Retry logic works for network errors
- [ ] Authentication errors fail fast with clear message
- [ ] Configuration validation runs on startup
- [ ] Logging output is helpful for debugging
- [ ] Documentation is complete and accurate
- [ ] Voice feedback for errors is natural and helpful
- [ ] Bot never crashes due to function call failures
- [ ] README includes troubleshooting section

## Notes

- **Logging Levels:** Use DEBUG during development, INFO in production
- **User Messages:** All error messages should be conversational and avoid technical jargon
- **Retry Strategy:** Only retry transient errors (network, timeout), not auth or validation errors
- **Configuration:** Validate on startup to catch issues early
- **Future:** Add metrics/monitoring for function call success rates
